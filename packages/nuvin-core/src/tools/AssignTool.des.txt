Delegate a task to a specialist agent for focused, independent execution.

The assign_task tool launches specialized agents that autonomously handle complex, multi-step tasks. Each agent has specific capabilities and tools available to it.

Available agents:
{AGENT_LIST}

When NOT to use this tool:
- To read a specific file path - use file_read instead (faster)
- To search for a class like "class Foo" - use grep_tool instead (faster)
- To search within 2-3 specific files - use file_read instead (faster)
- For simple, single-step tasks that don't need specialist knowledge

Usage notes:
- Always include a short description (5-10 words) summarizing what the agent will do
- Launch multiple agents concurrently by making parallel tool calls in a single message
- Set run_in_background=true to continue working while agent runs; use task_output tool to retrieve results later
- Use resume parameter with a session ID to continue a previous agent session with full context preserved
- Session IDs are returned in metadata.sessionId after each invocation
- When the agent completes, it returns a result to you (not visible to user) - summarize it for the user
- Provide clear, detailed task descriptions so agents can work autonomously
- Clearly specify whether you expect code writing or just research (search, reads, web fetches)
- Agent outputs should generally be trusted

Background execution workflow:
1. Launch: assign_task with run_in_background=true → returns session_id
2. Continue other work while agent runs
3. Retrieve: task_output with session_id → returns agent's result (use blocking=true to wait)

Session resumption:
- Pass session_id from previous invocation to resume parameter
- Agent continues with full conversation history preserved
- Useful for follow-up questions or continuing interrupted work

Examples of when and how to use assign_task:

<example>
User: "I need to create a reusable data table component with sorting, filtering, and pagination."
Assistant: "I'll use the code-investigator agent to analyze existing patterns and design a comprehensive data table component."
→ assign_task({ agent: "code-investigator", task: "Analyze codebase for table component patterns and design a reusable data table with sorting, filtering, pagination", description: "Design data table component" })
</example>

<example>
User: "My app is re-rendering too frequently. Can you help optimize it?"
Assistant: "I'll delegate this to the code-investigator agent to trace the rendering behavior and identify optimization opportunities."
→ assign_task({ agent: "code-investigator", task: "Trace component render cycles, identify unnecessary re-renders, and suggest memoization strategies", description: "Analyze React render performance" })
</example>

<example>
User: "I just finished writing the login authentication function. Can you take a look?"
Assistant: "I'll use the code-security-auditor agent to review your authentication code for security issues and best practices."
→ assign_task({ agent: "code-security-auditor", task: "Review the authentication function for security vulnerabilities, input validation, and secure coding practices", description: "Security review of auth function" })
</example>

<example>
User: "I've finished implementing the payment processing feature."
Assistant: "Let me have the code-security-auditor review this for security vulnerabilities before we proceed."
→ assign_task({ agent: "code-security-auditor", task: "Audit payment processing code for security flaws, PCI compliance issues, and error handling", description: "Security audit of payment code" })
</example>

<example>
User: "How does the data flow from API to database in this codebase?"
Assistant: "I'll launch the code-investigator agent to trace the data flow architecture."
→ assign_task({ agent: "code-investigator", task: "Trace data flow from API endpoints through service layers to database, document the architecture", description: "Map API to database flow" })
</example>

<example>
Context: Need to run multiple investigations in parallel
Assistant: "I'll launch two agents concurrently to speed this up."
→ [parallel tool calls]
   assign_task({ agent: "code-investigator", task: "Analyze frontend architecture", description: "Frontend analysis", run_in_background: true })
   assign_task({ agent: "code-investigator", task: "Analyze backend architecture", description: "Backend analysis", run_in_background: true })
→ Later: task_output({ session_id: "...", blocking: true })
</example>

<example>
Context: Need multiple agents to work on different aspects simultaneously (foreground parallel execution)
User: "Review my new feature - check both the code quality and security."
Assistant: "I'll launch both agents in parallel to review your code."
→ [parallel tool calls in single message]
   assign_task({ agent: "code-investigator", task: "Review code structure, patterns, and best practices in the new feature", description: "Code quality review" })
   assign_task({ agent: "code-security-auditor", task: "Audit the new feature for security vulnerabilities and input validation", description: "Security audit" })
→ Both results return together, then summarize findings to user
</example>
